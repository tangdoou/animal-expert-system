# 动物识别专家系统设计说明文档

**课程名称**：人工智能与专家系统  
**项目名称**：基于产生式系统的动物识别专家系统  
**姓名**：唐一璇  
**学号**：2022101068  
**完成日期**：2025年12月  
**GitHub仓库**：https://github.com/tangdoou/animal-expert-system  
**开发技术**：Python + Flask + Web前端

---

## 一、系统概述

### 1.1 项目背景

本项目旨在设计并实现一个基于产生式系统（Production System）的动物识别专家系统。系统严格遵循教材《人工智能与专家系统（第二版）》P19 例2.7 的规则库，并依据 5.3.2 节定义的正向推理机机制运行。

### 1.2 系统功能

本系统实现以下核心功能：

- **正向推理**（Forward Reasoning）：从已知特征出发，自底向上推导出动物种类
- **反向推理**（Backward Reasoning）：从目标动物出发，自顶向下验证特征是否满足
- **规则管理**：支持规则的增加、删除、修改操作
- **可视化推理过程**：展示详细的推理路径和中间结论

### 1.3 系统特点

- **前后端分离架构**：后端实现推理引擎，前端提供图形化交互界面
- **无数据库依赖**：使用 JSON 文件存储规则，降低部署复杂度
- **可扩展性强**：规则采用三层结构设计，便于增加新动物识别

---

## 二、系统架构设计

### 2.1 整体架构

系统采用 **B/S (浏览器/服务器)** 架构，分为三层：

```
┌─────────────────┐
│  前端交互层      │  HTML + CSS + JavaScript
│  (用户界面)      │  (特征选择、结果展示)
└────────┬────────┘
         │ HTTP API
┌────────▼────────┐
│  后端推理层      │  Python + Flask
│  (推理引擎)      │  (正向/反向推理、规则管理)
└────────┬────────┘
         │ JSON I/O
┌────────▼────────┐
│  数据存储层      │  rules.json
│  (规则库)        │  (产生式规则、特征列表)
└─────────────────┘
```

### 2.2 技术选型

| 组件 | 技术 | 说明 |
|------|------|------|
| 后端框架 | Flask | 轻量级 Python Web 框架 |
| 前端 | HTML/CSS/JavaScript | 原生技术，无框架依赖 |
| 数据存储 | JSON 文件 | 简单可靠，符合课程要求 |
| 推理引擎 | Python 纯算法实现 | 基于集合运算和栈结构 |

---

## 三、知识库设计（核心）

### 3.1 规则表示法

本系统采用**产生式规则**（Production Rule）表示知识，基本格式为：

```
IF <条件1> AND <条件2> AND ... THEN <结论>
```

### 3.2 规则数据结构

每条规则在程序中表示为一个 JSON 对象：

```json
{
  "id": "R1",
  "conditions": ["有毛发"],
  "conclusion": "哺乳动物",
  "type": "classification",
  "description": "有毛发的动物是哺乳动物"
}
```

**字段说明**：
- `id`：规则唯一标识符（R1-R20）
- `conditions`：前提条件列表（数组）
- `conclusion`：结论（字符串）
- `type`：规则类型（`classification` 或 `final`）
- `description`：规则描述（用于展示）

### 3.3 完整规则库

基于教材 P19 例2.7，扩展为 **20 条规则**，可识别 **12 种动物**：

#### 第一层：基础分类规则（R1-R8）

| 规则ID | 条件（IF） | 结论（THEN） |
|--------|-----------|-------------|
| R1 | 有毛发 | 哺乳动物 |
| R2 | 有奶 | 哺乳动物 |
| R3 | 有羽毛 | 鸟 |
| R4 | 会飞 AND 会生蛋 | 鸟 |
| R5 | 吃肉 | 食肉动物 |
| R6 | 有锋利牙齿 AND 有爪 AND 眼向前方 | 食肉动物 |
| R7 | 哺乳动物 AND 有蹄 | 有蹄类动物 |
| R8 | 哺乳动物 AND 反刍 | 有蹄类动物 |

#### 第二层：最终识别规则（R9-R20）

| 规则ID | 条件（IF） | 结论（THEN） |
|--------|-----------|-------------|
| R9 | 哺乳动物 + 食肉动物 + 有黄褐色皮毛 + 有暗斑点 | 豹 |
| R10 | 哺乳动物 + 食肉动物 + 有黄褐色皮毛 + 有黑色条纹 | 虎 |
| R11 | 哺乳动物 + 食肉动物 + 有黄褐色皮毛 + 有鬃毛 | 狮子 |
| R12 | 哺乳动物 + 食肉动物 + 有灰色皮毛 + 群居 | 狼 |
| R13 | 有蹄类动物 + 有长脖子 + 有长腿 + 有暗斑点 | 长颈鹿 |
| R14 | 有蹄类动物 + 有黑色条纹 | 斑马 |
| R15 | 有蹄类动物 + 有角 + 产奶 | 牛 |
| R16 | 有蹄类动物 + 能快跑 + 有长腿 | 马 |
| R17 | 鸟 + 不会飞 + 有长脖子 + 有长腿 + 有黑白二色 | 鸵鸟 |
| R18 | 鸟 + 不会飞 + 会游泳 + 有黑白二色 | 企鹅 |
| R19 | 鸟 + 善飞 | 信天翁 |
| R20 | 鸟 + 善飞 + 有锋利爪 + 吃肉 | 老鹰 |

### 3.4 规则库设计优势

**分层设计**：规则分为"分类层"和"识别层"，具有以下优点：

1. **容错性**：当特征不完全时，至少能给出分类结果（如"哺乳动物"）
2. **可扩展性**：增加新动物时，只需添加识别规则，无需修改分类规则

**中间结论**：系统定义了 4 个中间结论：
- 哺乳动物
- 鸟
- 食肉动物
- 有蹄类动物

这些中间结论在推理过程中可以被复用，提高推理效率。

---

## 四、综合数据库设计（核心）

### 4.1 数据结构

综合数据库（Fact Base）用于存储推理过程中的已知事实。

**数据结构**：采用 Python 的 **Set（集合）** 数据结构

```python
facts = {"有毛发", "吃肉", "有黄褐色皮毛", "有黑色条纹"}
```

**选择集合的原因**：
- 自动去重（避免重复添加同一事实）
- 快速成员检测（O(1) 复杂度）
- 支持子集判断（用于规则匹配）

### 4.2 事实库状态演变

**初始状态**：包含用户选择的特征

```python
facts = {"有毛发", "吃肉", "有黄褐色皮毛", "有黑色条纹"}
```

**推理过程**：动态添加推导出的中间结论

```python
# 第1步：触发 R1
facts = {"有毛发", "吃肉", "有黄褐色皮毛", "有黑色条纹", "哺乳动物"}

# 第2步：触发 R5
facts = {..., "食肉动物"}

# 第3步：触发 R10
facts = {..., "虎"}  # 推理成功
```

**终止状态**：包含最终识别的动物名称

### 4.3 事实库操作

系统对事实库的操作包括：

| 操作 | 方法 | 说明 |
|------|------|------|
| 初始化 | `facts = set(initial_facts)` | 从用户输入创建集合 |
| 添加事实 | `facts.add(conclusion)` | 添加推导结论 |
| 检查成员 | `condition in facts` | 判断条件是否满足 |
| 子集判断 | `conditions.issubset(facts)` | 判断规则是否可触发 |

---

## 五、推理机设计（核心）

### 5.1 正向推理算法

#### 5.1.1 算法原理

正向推理（Forward Reasoning）是**数据驱动**的推理方式，从已知事实出发，逐步应用规则推导结论。

**推理流程**（依据教材 5.3.2 节）：

```
1. 初始化事实库 facts = 用户选择的特征
2. WHILE 有规则可触发:
   3. FOR each rule in rules:
      4. IF rule.conditions ⊆ facts AND rule.conclusion ∉ facts:
         5. facts.add(rule.conclusion)
         6. 记录推理路径
         7. IF conclusion 是最终动物:
            8. RETURN 推理成功
         9. BREAK  // 冲突消解：触发一条后重新扫描
10. RETURN 推理失败（特征不足）
```

#### 5.1.2 核心代码

```python
def forward_reasoning(initial_facts):
    facts = set(initial_facts)
    process_log = []
    triggered_rules = set()  # 已触发的规则
    
    while True:
        rule_triggered = False
        
        for rule in rules:
            conditions = set(rule['conditions'])
            conclusion = rule['conclusion']
            
            # 规则匹配：前提满足 + 结论未知 + 规则未触发
            if (conditions.issubset(facts) and 
                conclusion not in facts and 
                rule['id'] not in triggered_rules):
                
                # 触发规则
                facts.add(conclusion)
                triggered_rules.add(rule['id'])
                process_log.append(rule)
                
                # 检查是否得出最终动物
                if conclusion in animals:
                    return {'success': True, 'animal': conclusion}
                
                rule_triggered = True
                break  # 重新扫描
        
        if not rule_triggered:
            break  # 无新规则触发，结束
    
    return {'success': False, 'message': '无法识别'}
```

#### 5.1.3 冲突消解策略

当多条规则同时满足触发条件时，称为发生**冲突**。本系统采用以下策略：

1. **顺序优先**：按规则在规则库中的顺序（R1-R20）选择第一条可用规则
2. **单次触发**：每次只触发一条规则，然后重新扫描规则库
3. **去重机制**：已触发的规则不再触发（通过 `triggered_rules` 集合实现）

#### 5.1.4 终止条件

推理终止的两种情况：

1. **成功终止**：推导出最终动物（结论在动物列表中）
2. **失败终止**：遍历所有规则后无新规则可触发

### 5.2 反向推理算法

#### 5.2.1 算法原理

反向推理（Backward Reasoning）是**目标驱动**的推理方式，从目标结论出发，逆向验证所需条件。

**推理流程**：

```
1. goal_stack.push(目标动物的规则)
2. WHILE goal_stack 非空:
   3. current_rule = goal_stack.top()
   4. FOR each condition in current_rule.conditions:
      5. IF condition 已知: continue
      6. IF condition 是中间结论 AND 用户选择"不确定":
         7. sub_rule = find_rule_for(condition)
         8. goal_stack.push(sub_rule)  // 递归验证
      9. ELSE:
         10. 询问用户 condition 是否成立
         11. IF 回答"否": RETURN 验证失败
   12. goal_stack.pop()  // 当前规则所有条件满足
13. RETURN 验证成功
```

#### 5.2.2 核心代码

```python
class BackwardReasoner:
    def __init__(self):
        self.known_facts = set()
        self.denied_facts = set()
        self.goal_stack = []
        self.current_question = None
    
    def start(self, target_animal):
        # 找到目标动物的规则
        rule = self._find_rule_for_conclusion(target_animal)
        
        # 压入目标栈
        self.goal_stack.append({
            'rule': rule,
            'condition_index': 0
        })
        
        return self._process_next()
    
    def _process_next(self):
        while self.goal_stack:
            current = self.goal_stack[-1]
            rule = current['rule']
            conditions = rule['conditions']
            
            # 检查每个条件
            while current['condition_index'] < len(conditions):
                condition = conditions[current['condition_index']]
                
                if condition in self.known_facts:
                    current['condition_index'] += 1
                    continue
                
                if condition in self.denied_facts:
                    return {'status': 'failed'}
                
                # 询问用户
                self.current_question = condition
                current['condition_index'] += 1
                
                return {
                    'status': 'asking',
                    'question': condition,
                    'is_intermediate': condition in intermediates
                }
            
            # 所有条件满足，推导结论
            conclusion = rule['conclusion']
            self.known_facts.add(conclusion)
            self.goal_stack.pop()
            
            if conclusion == target_animal:
                return {'status': 'success'}
        
        return {'status': 'failed'}
```

#### 5.2.3 递归验证机制

当用户对某个条件回答"不确定"时，如果该条件是**中间结论**（如"哺乳动物"），系统会：

1. 找到推导该中间结论的规则
2. 将该规则压入目标栈
3. 递归验证该规则的所有条件

**示例**：验证"企鹅"

```
目标: 企鹅 (R18)
  条件1: 鸟 → 用户回答"不确定" → 递归验证
    → 压入 R3: 鸟 ← 有羽毛
      条件: 有羽毛 → 询问用户 → 回答"是"
    → 弹出 R3，得出"鸟"
  条件2: 不会飞 → 询问用户 → 回答"是"
  条件3: 会游泳 → 询问用户 → 回答"是"
  条件4: 有黑白二色 → 询问用户 → 回答"是"
→ 所有条件满足，确认是"企鹅"
```

---

## 六、规则管理功能

### 6.1 功能设计

系统提供完整的规则 CRUD（增删改查）操作：

| 功能 | HTTP 方法 | API 接口 | 说明 |
|------|-----------|---------|------|
| 查看规则 | GET | `/api/rules` | 获取所有规则 |
| 添加规则 | POST | `/api/rules` | 创建新规则 |
| 修改规则 | PUT | `/api/rules/<id>` | 更新指定规则 |
| 删除规则 | DELETE | `/api/rules/<id>` | 删除指定规则 |

### 6.2 规则验证

添加或修改规则时，系统会自动：

1. 生成唯一的规则 ID（如 R21）
2. 根据结论判断规则类型（`classification` 或 `final`）
3. 验证 JSON 格式正确性
4. 持久化到 `rules.json` 文件

---

## 七、用户界面设计

### 7.1 界面结构

系统采用**单页应用**（SPA）设计，包含 4 个功能页面：

1. **正向推理页面**：勾选特征 → 开始推理 → 显示结果
2. **反向推理页面**：选择目标动物 → 回答问题 → 验证结果
3. **规则管理页面**：规则列表 + 增删改操作
4. **关于页面**：系统说明和技术文档

### 7.2 交互流程

#### 正向推理流程

```
用户选择特征 → 点击"开始推理" 
  ↓
发送 POST /api/forward
  ↓
后端执行正向推理
  ↓
返回推理结果和路径
  ↓
前端展示动物名称 + 推理步骤
```

#### 反向推理流程

```
用户选择目标动物 → 点击"开始验证"
  ↓
发送 POST /api/backward/start
  ↓
后端返回第一个问题
  ↓
用户回答"是/否/不确定"
  ↓
发送 POST /api/backward/answer
  ↓
循环询问直到验证成功/失败
```

---

## 八、测试验证

### 8.1 正向推理测试

#### 测试用例 1：识别"虎"

**输入特征**：
- 有毛发
- 吃肉
- 有黄褐色皮毛
- 有黑色条纹

**推理过程**：
1. 触发 R1：`有毛发` → `哺乳动物`
2. 触发 R5：`吃肉` → `食肉动物`
3. 触发 R10：`哺乳动物 + 食肉动物 + 有黄褐色皮毛 + 有黑色条纹` → `虎`

**预期结果**：✅ 虎  
**实际结果**：✅ 虎  
**测试状态**：通过

#### 测试用例 2：识别"长颈鹿"

**输入特征**：
- 有毛发
- 有蹄
- 有长脖子
- 有长腿
- 有暗斑点

**推理过程**：
1. 触发 R1：`有毛发` → `哺乳动物`
2. 触发 R7：`哺乳动物 + 有蹄` → `有蹄类动物`
3. 触发 R13：`有蹄类动物 + 有长脖子 + 有长腿 + 有暗斑点` → `长颈鹿`

**预期结果**：✅ 长颈鹿  
**实际结果**：✅ 长颈鹿  
**测试状态**：通过

### 8.2 反向推理测试

#### 测试用例 3：验证"企鹅"

**目标动物**：企鹅

**问答序列**：

| 问题 | 回答 |
|------|------|
| 是鸟吗？ | 是 |
| 不会飞吗？ | 是 |
| 会游泳吗？ | 是 |
| 有黑白二色吗？ | 是 |

**验证结果**：✅ 确认是企鹅  
**测试状态**：通过

#### 测试用例 4：验证失败情况

**目标动物**：虎

**问答序列**：

| 问题 | 回答 |
|------|------|
| 是哺乳动物吗？ | 是 |
| 是食肉动物吗？ | 否 ❌ |

**验证结果**：❌ 因为不满足条件"食肉动物"，无法确认是虎  
**测试状态**：通过（正确拒绝）

### 8.3 规则管理测试

| 功能 | 测试内容 | 结果 |
|------|---------|------|
| 添加规则 | 添加 R21: `有蹄类动物 + 有角 + 体型大` → `水牛` | ✅ 通过 |
| 修改规则 | 修改 R1 的描述文字 | ✅ 通过 |
| 删除规则 | 删除 R21 | ✅ 通过 |

---

## 九、项目文件结构

```
/专家系统/
├── app.py                 # Flask 后端（推理引擎 + API）
├── rules.json             # 规则库数据文件（20条规则）
├── requirements.txt       # Python 依赖
├── static/
│   ├── css/
│   │   └── style.css      # 样式文件（深色主题）
│   └── js/
│       └── main.js        # 前端交互逻辑
├── templates/
│   └── index.html         # 主页面（单页应用）
├── screenshots/           # 系统截图
└── README.md              # 项目说明
```

---

## 十、运行说明

### 10.1 环境要求

- Python 3.7+
- Flask 3.0.0

### 10.2 安装步骤

```bash
# 1. 安装依赖
pip install -r requirements.txt

# 2. 运行系统
python app.py

# 3. 访问系统
# 浏览器打开 http://127.0.0.1:5000
```

---

## 十一、总结与展望

### 11.1 系统优势

1. **严格遵循教材**：规则库基于 P19 例2.7，推理机实现参考 5.3.2 节
2. **前后端分离**：架构清晰，易于维护和扩展
3. **双向推理**：同时支持正向和反向推理，功能完整
4. **可视化展示**：推理过程透明，便于理解和调试
5. **规则可管理**：支持动态增删改规则，无需重启系统

### 11.2 可扩展方向

1. **知识库扩展**：添加更多动物识别规则（如猫、狗、鱼类等）
2. **解释机制**：增加"为什么需要这个特征"的解释功能
3. **不确定性推理**：引入置信度概念，处理模糊信息
4. **学习功能**：从用户反馈中自动生成新规则
5. **多语言支持**：支持中英文切换

---

**文档编写日期**：2025年12月  
**系统版本**：v1.0
