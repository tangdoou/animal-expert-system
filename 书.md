**例 2.7** 建立一个动物识别系统的规则库，用以识别虎、豹、斑马、长颈鹿、企鹅、鸵鸟、信天翁等 7 种动物。

**解：** 为了识别这些动物，可以根据动物识别的特征，建立包含下述规则的规则库：

* **:** if 动物有毛发 then 动物是哺乳动物
* **:** if 动物有奶 then 动物是哺乳动物
* **:** if 动物有羽毛 then 动物是鸟
* **:** if 动物会飞 and 会生蛋 then 动物是鸟
* **:** if 动物吃肉 then 动物是食肉动物
* **:** if 动物有锋利牙齿 and 有爪 and 眼向前方 then 动物是食肉动物
* **:** if 动物是哺乳动物 and 有蹄 then 动物是有蹄类动物
* **:** if 动物是哺乳动物 and 反刍 then 动物是有蹄类动物
* **:** if 动物是哺乳动物 and 是食肉动物 and 有黄褐色皮毛 and 有暗斑点 then 动物是豹
* **:** if 动物是哺乳动物 and 是食肉动物 and 有黄褐色皮毛 and 有黑色条纹 then 动物是虎
* **:** if 动物是有蹄类动物 and 有长脖子 and 有长腿 and 有暗斑点 then 动物是长颈鹿
* **:** if 动物是有蹄类动物 and 有黑色条纹 then 动物是斑马
* **:** if 动物是鸟 and 不会飞 and 有长脖子 and 有长腿 and 有黑白二色 then 动物是鸵鸟
* **:** if 动物是鸟 and 不会飞 and 会游泳 and 有黑白二色 then 动物是企鹅
* **:** if 动物是鸟 and 善飞 then 动物是信天翁

由上述产生式规则可以看出，虽然该系统是用来自别 7 种动物的，但并不是简单地只设计 7 条规则分别直接用于识别 7 种动物。规则设计的基本思想是：首先把动物划分为若干类，如“哺乳动物”、“鸟”、“食肉动物”、“有蹄类动物”等，根据“类”的识别特征建立若干条规则，如规则 ，然后对属于各类的各个动物根据其个性的识别特征建立各自相应的规则，如规则 。

这样做至少有两个好处：

1. **容错性：** 当给出的已知事实不完全时，虽然不能推出最终结论，但可能会给出分类结果；
2. **可扩展性：** 当需要增加对其他动物（如牛、马等）的识别要求时，规则库中只需增加关于这些动物个性方面的知识，对于规则库中已有的分类知识（如规则 ）就可以直接使用。

---

**页码标注：** 20 | 人工智能与专家系统（第二版）

---


---

### 5.3.2 正向推理机

产生式系统有正向推理和反向推理两种基本推理方式，本节首先给出用 LISP 语言编写的正向推理机。

正向推理过程如下：根据在综合数据库中给出的已知事实，正向使用规则，即通过把规则的前件同当前数据库的内容进行匹配来选取可用规则。若有多条规则可用，则按冲突消解策略从中选择一条规则执行，将该规则的结论添加到综合数据库中，直至问题求解或没有可用规则。

LISP 语言是函数型语言，因此，用 LISP 语言实现的正向推理机也是一个函数。首先给出正向推理机需要调用的几个函数的定义，最后给出实现的正向推理机。

用 LISP 语言编制的产生式系统中的综合数据库的存储结构也是一个表，用 **facts** 作为综合数据库表的表名。

#### 1. 函数 recall

（1）函数表达式：
`(recall fact)`
（2）函数功能：判断变量 fact 中的一个事实是否在表 facts 中，若是，recall 返回值是 fact 中的事实；否则，返回 nil。
（3）函数定义：

```lisp
(defun (recall fact)
    (cond ((member fact facts) fact)
          (t nil)))

```

#### 2. 函数 test-if

（1）函数表达式：
`(test-if rule)`
（2）函数功能：判断变量 rule 中的一条规则的前件包含的全部事实是否在表 facts 中，若是，test-if 返回 t；否则，返回 nil。
（3）函数定义：

```lisp
(defun (test-if rule)
    (prog (ifs)
        (setq ifs (cdadr rule))
        loop
        (cond ((null ifs) (return t))
              ((recall (car ifs)))
              (t (return nil)))
        (setq ifs (cdr ifs))
        (go loop)))

```

#### 3. 函数 remember

（1）函数表达式：
`(remember new)`
（2）函数功能：判断变量 new 中的一个事实是否在表 facts 中，若是，remember 返回 nil；否则，将 new 中的事实添加到表 facts 的表头，且 remember 返回 new 中的事实。
（3）函数定义：

```lisp
(defun (remember new)
    (cond ((member new facts) nil)
          (t (setq facts (cons new facts)) new)))

```

#### 4. 函数 use-then

（1）函数表达式：
`(use-then rule)`
（2）函数功能：判断变量 rule 中的一条规则的后件包含的全部结论是否在表 facts 中，若全部结论都在 facts 中，则 use-then 返回 nil；否则，将不在 facts 中的结论逐一添加到表 facts 中，且 use-then 返回 t。
（3）函数定义：

```lisp
(defun (use-then rule)
    (prog (thens success)
        (setq thens (cdddr rule))
        loop
        (cond ((null thens) (return success))
              ((remember (car thens))
               (print (car rule))
               (print '|DEDUCES| (car thens))
               (setq success t)))
        (setq thens (cdr thens))
        (go loop)))

```

在 use-then 的函数定义中 2 次调用了 LISP 输出函数 print，把输出流定向输出到显示终端。第 2 次调用的 print 函数的输出使用了转义符“|”，两个“|”之间的所有字符都作为普通字符而失去原定义的语法含义。屏幕显示 rule 中的规则名，换行显示 DEDUCES 和 thens 中的第一个元素。

#### 5. 函数 try-rule

（1）函数表达式：
`(try-rule rule)`
（2）函数功能：判断规则变量 rule 中的一条规则的前件包含的全部事实是否在表 facts 中，若全部事实都在 facts 中，且规则后件有不在 facts 中的结论，则把不在 facts 中的结论逐一添加到表 facts 中，try-rule 返回 t；否则，try-rule 返回 nil。
（3）函数定义：

```lisp
(defun (try-rule rule)
    (and (test-if rule) (use-then rule)))

```

#### 6. 函数 step-forward

（1）函数表达式：
`(step-forward rules)`
（2）函数功能：逐次扫描规则库 rules 中的规则，若发现 rules 中有一条可用规则，即该规则的前件包含的全部事实在表 facts 中，则把该规则的后件中不在 facts 中的所有结论添加到 facts 中，且 step-forward 返回 t；若 rules 中没有一条可用规则，则 step-forward 返回 nil。
（3）函数定义：

```lisp
(defun (step-forward rules)
    (prog (rule-list)
        (setq rule-list rules)
        loop
        (cond ((null rule-list) (return nil))
              ((try-rule (car rule-list)) (return t)))
        (setq rule-list (cdr rule-list))
        (go loop)))

```

#### 7. 正向推理机函数 deduce

step-forward 函数只从 rules 中选择一条可用规则，并使用该规则对 facts 作一次扩充。推理机要完成推理，通常要对 facts 进行多次扩充，也就是说，按扩充了的 facts 继续从 rules 中选择可用规则，对 facts 再扩充，直至没有可用规则可选，不能对 facts 再扩充为止。正向推理机 deduce 可用 step-forward 函数来定义。

（1）函数表达式：
`(deduce facts)`
（2）函数功能：连续不断地从规则库 rules 中选择可用规则，每选择到一条可用规则，就把该规则的后件中不在 facts 中的所有结论添加到 facts 中，对 facts 扩充，由扩充了的 facts 来选择下一条可用规则对 facts 再次扩充，直至没有可用规则可选为止。若曾找到一条可用规则对 facts 进行过一次扩充，则 deduce 返回 t；否则，deduce 返回 nil。
（3）函数定义：

```lisp
(defun (deduce facts)
    (prog (progress)
        loop
        (cond ((step-forward rules) (setq progress t))
              (t (return progress)))
        (go loop)))

```

---

**例 5.6** 对于动物识别专家系统，若已知的初始事实是 、、 和 ，应用正向推理机 deduce，说明推理过程和得出的推理结论。

**解：** 使用 setq 函数把已知初始事实赋值给事实表 facts:

```lisp
(setq facts
    '((animal has dark spots)
      (animal has tawny color)
      (animal eats meat)
      (animal has hair)))

```

即有 facts = (   )。
调用正向推理机 `(deduce facts)`，使用的规则库 rules 是例 5.5 给出的规则库。推理过程说明如下：

① 在 rules 中查找规则前件的全部条件在当前 facts = (   ) 中的可用规则，首先找到规则 ，则把  后件中不在 facts 中的结论  添加到 facts 中，扩充 facts 为 facts = (    )。
实际上，对 facts = (   )，还有另一条可用规则 ，因为  的前件  也在当前 facts 中。但是，由 step-forward 函数定义的冲突消解策略是：若有多条可用规则，则按可用规则在规则库表 rules 中的顺序选择第一条可用规则。因此，首先选择  把 facts 扩充为 facts = (    )。

② 对当前 facts 在 rules 中查找可用规则，仍然找到规则 ，但  的后件结论  已在 facts 中，因此不会执行规则 。继续查找可用规则，找到规则 ，因为  的后件结论  不在当前 facts 中，故执行 ，把  不在 facts 中的结论  添加到 facts 中，扩充 facts 为 facts = (     )。

③ 对当前 facts 在 rules 中继续查找可用规则，只有规则  的前件包含的全部条件 、、 和  在 facts 中，且  的后件结论  不在 facts 中，故而执行可用规则 ，把  的结论  扩充到 facts 中，使得 facts = (      )。

④ 对当前 facts，在 rules 中找不到规则的前件在 facts 中包含的全部条件且后件有不在 facts 中的结论的任何规则，经过 4 步推理，正向推理终止，推理机函数 deduce 返回的变量 progress 的值为 t。

实际上，这个推理过程是按图 5.4 所示的规则库与/或图的一个子图正向进行推理的。推理过程终止后，解释器取当前 facts 中的第一个元素得出推理的结论是 ，即 **(animal is cheetah)**。

---

**页码标注：**
112 | 113 | 114 | 115
**书名：** 人工智能与专家系统（第二版）